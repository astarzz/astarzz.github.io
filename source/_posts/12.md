---
title: 分布式环境全局唯一ID
date: 2019-09-15 12:01:03
categories: 
    - "分布式"
toc_number: false
tags:
	- zookeeper
	- snowflake
---
## 前言
目前流行的分布式架构，为我们带来了许多以前传统的单机、集群架构所没有的好处。
- 降低系统耦合
- 系统更易于扩展
- 服务可弹性伸缩
- 程序复用性更高
- 高可用

但凡事无绝对，有利就有弊，分布式也有它的痛点。
- 分布式锁、分布式事务、数据一致性等问题，导致架构设计变得复杂
- 调用链过多，响应速度下降
- 系统服务过多，运维部署复杂
- 测试和查错的复杂度增大

<!--more-->
## 分布式ID
分布式架构下，怎么生成全局唯一ID就是其中比较常见的问题，这里分享几个方案。

### 数据库序列
数据库序列是一个最简单的处理方案，利用其自身机制实现全库唯一.
最常用的就是oracle的sequence，保证ID的唯一且递增。
**优点**
1. 简单方便，一行代码的事
2. 数字类型，直观并可进行排序

**缺点**
1. 性能容易瓶颈，不易扩展
2. 太依赖数据库，无法做多源数据兼容

### redis
redis是一个高性能的内存数据库，并且它是单线程的，所有的命令都是原子性操作，所以可以利用这个特性保证ID在高并发性唯一。
redis有2个数值递增命令INCR和INCRBY，INCR是每次递增1，INCRBY可加步长参数。
**优点**
1. 高性能，能从容应对高并发
2. 不再依赖于特定数据库
3. 数字类型，直观并可进行排序

**缺点**
1. 引入新组件，依赖其高可用

### zookeeper
得益于zk提供的数据强一致性，通过其临时有序节点实现的分布式锁，可以保证在高并发下全局唯一ID。
但是既然是锁，性能上肯定是有一定损耗。这里可以利用步长，减少锁的使用。
比如每次获取锁，获取序列值，加上程序里计算好的待入库数据量，回写zk。然后在程序里利用这个区间段，生成每条数据的ID。

### snowflake雪花算法
snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。
使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0。
**优点**
1. 高性能，每秒可生成400万个ID
2. 纯算法，不依赖数据库、第三方组件
3. 数字类型，直观并可进行排序

**缺点**
没有太明显的缺点，如果硬要要说可能就是代码相对复杂些，且没有像其他第三方组件那样的成熟的唯一性保证，需要自身多测试验证。
