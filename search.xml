<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>前端国际化</title>
      <link href="/2019/02/19/six/"/>
      <url>/2019/02/19/six/</url>
      
        <content type="html"><![CDATA[<p>公司需要开拓一个国外市场，很是看重，就给我们项目组提了些功能需求(包装美化)。其中就包括国际化问题，多语言切换是一个很重要的竞标资本。<br>国际化相关技术并不复杂，但涉及的点还是比较多的，前后端、数据、硬编码等等，作业量也不小。<br>这篇文章仅先探讨下前端国际化的细节。</p><a id="more"></a><h2 id="i18n"><a href="#i18n" class="headerlink" title="i18n"></a>i18n</h2><p>i18n全称internationalization，是国际化的简称，因单词过长，而i和n之间有18个字符故缩写为i18n。</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>js的国际化采用的市面上比较流行的jquery.i18n插件，轻量级，使用方法简单。<br>配置不同的语言(en、zh_CN等)的properties，每个文件一一对应相同的key(key不能重复)，value则是不同语言的释义。<br>简单的讲，就是获得切换语言的指令，在显示调用’key’的位置，置换成指定语言的value。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="资源文件"><a href="#资源文件" class="headerlink" title="资源文件"></a>资源文件</h3><p>因为只是目前只是竞标阶段，所以暂时考虑中、英两种语言。<br><img src="/2019/02/19/six/i18n-web-1.png" alt="littleCoder"><br>文件路径可自行定义<br>其中common.properties,可作为组件级或常用、通用的配置<br><img src="/2019/02/19/six/i18n-web-2.png" alt="littleCoder"><br><img src="/2019/02/19/six/i18n-web-3.png" alt="littleCoder"><br>中英文一一对应</p><h3 id="代码配置"><a href="#代码配置" class="headerlink" title="代码配置"></a>代码配置</h3><p><img src="/2019/02/19/six/i18n-web-4.png" alt="littleCoder"><br>name是资源文件名称<br>path是资源文件路径<br>mode代表模式，有map、vars和both<br>language是从cookie中读取的指定语言，服务端读取后在jsp渲染时传入页面<br>简单的说就是加载path路径下name+language的文件</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>js中使用i18n非常简单，在你需要国际化的位置用<strong>$.i18n.prop(“key”)</strong>替换掉原来的中文，如上面图中$.i18n.prop(“calculate_add”)<br>也可利用js原型的特性，给String加上i18n方法简化代码<br><img src="/2019/02/19/six/i18n-web-5.png" alt="littleCoder"><br>使用则变成了<strong>“key”.i18n()</strong>,如”calculate_add”.i8n()</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> i18n </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>当幸福来敲门</title>
      <link href="/2018/12/10/five/"/>
      <url>/2018/12/10/five/</url>
      
        <content type="html"><![CDATA[<ul><li><em>Don’t ever let somebody tell you you can’t do something, not even me.</em></li><li><em>You got a dream, you gotta protect it.</em></li><li><em>People can’t do something by themselves,they wanna tell you you can not do it.</em></li><li><em>You want something. Go get it！</em></li></ul><p><img src="/2018/12/10/five/happiness.jpeg" alt="The Pursuit of Happiness"></p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> life </tag>
            
            <tag> movie </tag>
            
            <tag> inspirational </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript多叉树的遍历方式</title>
      <link href="/2018/11/23/four/"/>
      <url>/2018/11/23/four/</url>
      
        <content type="html"><![CDATA[<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul><li>一个根节点，它下面有若干个(0-N)子节点，这些子节点下面又有属于各自的若干子节点，以此类推，构成一棵树。没有子节点的节点是叶子节点，有相同父节点的为兄弟节点。</li><li>多叉树在JavaScript中应用频繁，dom对象也是利用这种数据结构存储。还有数据库中的父子、上下级关系数据，在前台展示的时候需要体现层级效果，所以很多前端框架都有相关树形插件实现，比如easyui的tree、ztree。</li><li>树形结构的数据，在使用、处理过程中不免需要访问节点数据或转换成平级列表，这里就涉及到它的遍历。<a id="more"></a></li></ul><h3 id="图形表示"><a href="#图形表示" class="headerlink" title="图形表示"></a>图形表示</h3><p><img src="/2018/11/23/four/tree.png" alt="alt"></p><h3 id="json格式"><a href="#json格式" class="headerlink" title="json格式"></a>json格式</h3>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  &quot;id&quot;: 1,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  &quot;text&quot;: &quot;Node 1&quot;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  &quot;children&quot;: [&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">      &quot;id&quot;: 11,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">      &quot;text&quot;: &quot;Node 11&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  &#125;,&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">      &quot;id&quot;: 12,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">      &quot;text&quot;: &quot;Node 12&quot;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">      &quot;children&quot;:[&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">          &quot;id&quot;: 22,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">          &quot;text&quot;: &quot;Node 22&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">      &#125;]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">  &#125;]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h2 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h2><h3 id="广度优先"><a href="#广度优先" class="headerlink" title="广度优先:"></a>广度优先:</h3><p>  从根节点开始，按照节点的层次，从上往下一级一级访问，每一级访问完所有节点后再往下一级访问，直至没有下一级。原则:有同级先访问同级，没有就找下一级<br>  <img src="/2018/11/23/four/wide.png" alt="alt"><br>   A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;F-&gt;G</p><ul><li><p>非递归方式(队列实现):</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">function wideFirst(node,callback) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    let nodes &#x3D; [];&#x2F;&#x2F;平级列表</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    if (node) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        let queue &#x3D; [];&#x2F;&#x2F;队列</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        queue.push(node);&#x2F;&#x2F;根节点处理</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        while (queue.length &gt; 0) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            node &#x3D; queue.shift();&#x2F;&#x2F;队列删除第一个，先进先出</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            nodes.push(node);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            if(callback)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">                callback(node);&#x2F;&#x2F;回调函数</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">            let childs &#x3D; node.children;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">                if(childs)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">                    for (let i &#x3D; 0,len&#x3D;childs.length; i&lt;len ;i++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">                        queue.push(childs[i]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    return nodes;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure></li></ul><h3 id="深度优先"><a href="#深度优先" class="headerlink" title="深度优先:"></a>深度优先:</h3><p>从根节点开始，按照一条完整的分支线区分(从根节点到每一个叶子节点的路线)，从左往右(或从右往左)访问各个分支。<strong>在节点不重复访问的前提下</strong>，每一个分支从上往下访问各个节点。原则:有子节点优先访问子节点，没有子节点找兄弟节点,还是没有再找父节点的兄弟节点。<br><img src="/2018/11/23/four/deep.png" alt="alt"><br>  A-&gt;B-&gt;E-&gt;C-&gt;F-&gt;G-&gt;D</p><ul><li><p>递归方式:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">function deepFirst(node,callback)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    let nodes &#x3D; [];&#x2F;&#x2F;平级列表</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    if(node)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        deepFirstTo(node,nodes,callback);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    return nodes;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">function deepFirstTo(node,nodes,callback) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    if (node) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        nodes.push(node);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        if(callback)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">            callback(node);&#x2F;&#x2F;回调函数</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        let childs &#x3D; node.children;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        if(childs)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">            for (var i &#x3D; 0,len &#x3D; childs.length; i&lt; len; i++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">                deepFirstTo(childs[i],nodes,callback);  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure></li><li><p>非递归方式(栈实现):</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">function deepFirst(node,callback) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    let nodes &#x3D; [];&#x2F;&#x2F;平级列表</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    if (node) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        var stack &#x3D; [];&#x2F;&#x2F;栈</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        stack.push(node);&#x2F;&#x2F;处理根节点</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        while (stack.length &gt; 0) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            node &#x3D; stack.pop();&#x2F;&#x2F;栈删除最后一个，后进先出</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            nodes.push(node);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            if(callback)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">                callback(node);&#x2F;&#x2F;回调</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">            let childs &#x3D; node.children;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            if(childs)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">                for (let i &#x3D; 0,len &#x3D; childs.length; i &lt; len; i++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">                    stack.push(childs[i]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    return nodes;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 多叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql多对多的数据的一种存储方案</title>
      <link href="/2018/11/16/third/"/>
      <url>/2018/11/16/third/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之所以做这个算法，缘由一个数据库设计的需求：mysql数据库2张多对多关系表，在不使用中间表的情况下，实现关联。<br>接到需求的时候，多少有点惊讶，mysql还有这种特性？实际了解之后发现，和我想的不同，而且实用性不大，但不乏是一种解决问题的思路。</p><a id="more"></a><hr><h2 id="实现条件"><a href="#实现条件" class="headerlink" title="实现条件"></a>实现条件</h2><ul><li>数据库支持位运算</li><li>2张表数据量不大</li></ul><hr><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><ul><li>2的N次方转换成二进制：2^0 = 1 -&gt; 0001、2^1 = 2 -&gt; 0010、2^2 = 4 -&gt; 0100… 在二进制运算中，这些数值在<strong>不相同的情况下</strong>相加不会出现进位情况 0001 + 0010 = 0011、0100 + 0010 = 0110 因为数值位1是错位的。</li><li>位运算符&amp;：按位与，其功能是参与运算的两数各对应的二进位相与，只要对应的两个二进位都为1时，结果位就为1。0011 &amp; 0001 = 0001。</li><li>当然的，相同数值位与得到值的即本身：0001 &amp; 0001 = 0001。</li><li>综合上面的条件，两个<strong>值不同的</strong>2的N次幂相加的和，按位与(&amp;)任意加数会得到加数本身。通过<strong>它们的和</strong>能判断出是否包含某个加数或者求得所有加数。</li></ul><hr><h3 id="java实现"><a href="#java实现" class="headerlink" title="java实现"></a>java实现</h3><p>代码:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">int d &#x3D; 31;&#x2F;&#x2F;d可以是任意正整数，因为二级制位不是0就是1，2的N次方数值本身还有求和的数值正好满足所有可能</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">for (int r &#x3D; 1; d &gt;&#x3D; r; r &#x3D; r &lt;&lt; 1) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">if ((d &amp; r) &#x3D;&#x3D; r) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">System.out.println(r);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>结果：<br>1<br>2<br>4<br>8<br>16  </p><p>1 + 2 + 4 + 8 + 16 = 31</p><hr><h3 id="数据库实现"><a href="#数据库实现" class="headerlink" title="数据库实现"></a>数据库实现</h3><ol><li>a表包含字段a_id,数值由代码维护，保证是2的N次方且唯一</li><li>b表包含字段a_ids,对应多个a表记录_id字段的和</li><li>查询b表关联的a表记录:select a.* from a,b where <strong>b.a_ids &amp; a.a_id = a.a_id</strong> and b.b_id = ?</li></ol><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>不使用中间表，节省了数据库空间</li><li>少了张表的关联也提升了查询效率</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>缺少中间表，也就不能做更多配置,比如可以在中间表中配置过滤、格式化规则</li><li>2的N次幂数值增长太快，大大限制了表中数据量</li><li>被关联表的修改、删除会影响关联表的数据，维护成本增加</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 二进制 </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql不支持full join解决方案</title>
      <link href="/2018/11/02/second/"/>
      <url>/2018/11/02/second/</url>
      
        <content type="html"><![CDATA[<p>项目因为需要支持多个省份的不同运行环境，其中最大的差异自于数据库，mysql和oracle。每迭代一个新功能，都需要对数据库进行兼容测试，维护两套sql。<br>同为关系型数据库，但基础语法还是有些许差异。最近就有个新需求，因为mysql不支持full join制造了点小插曲，觉得还是有必要记录下来。</p><a id="more"></a><h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><ul><li><p>目前有2张表：friends(朋友)、wokrmates(同事)，描述如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">mysql&gt;desc friends;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">+--------------+--------------+------+-----+---------+-------------- </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">--+</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">| Field        | Type         | Null | Key | Default | Extra          </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">|</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">+--------------+--------------+------+-----+---------+-------------- </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">--+</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">| id           | int(11)      | NO   | PRI | NULL    | </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">auto_increment |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">| belong       | int(11)      | YES  |     | NULL    |                </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">|</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">| friend_count | int(11)      | YES  |     | 0       |                </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">|</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">| desc         | varchar(100) | YES  |     | NULL    |                </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">|</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">+--------------+--------------+------+-----+---------+--------------          </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">--+</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">4 rows in set (0.00 sec)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">+----+--------+--------------+----------------+</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">| id | belong | friend_count | desc           |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">+----+--------+--------------+----------------+</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">|  1 |      1 |           99 | astar的朋友    |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">|  2 |      2 |           77 | jone的朋友     |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">|  3 |      3 |            8 | tom的朋友      |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">|  4 |      5 |          233 | mark的朋友     |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">+----+--------+--------------+----------------+</span></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">mysql&gt; desc workmates;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">+----------------+--------------+------+-----+---------+------------ </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">----+</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">| Field          | Type         | Null | Key | Default | Extra          </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">|</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">+----------------+--------------+------+-----+---------+------------ </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">----+</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">| id             | int(11)      | NO   | PRI | NULL    | </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">auto_increment |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">| belong         | int(11)      | YES  |     | NULL    |                </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">|</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">| workmate_count | int(11)      | YES  |     | 0       |                </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">|</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">| desc           | varchar(100) | YES  |     | NULL    |                </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">|</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">+----------------+--------------+------+-----+---------+------------ </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">----+</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">+----+--------+----------------+----------------+</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">| id | belong | workmate_count | desc           |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">+----+--------+----------------+----------------+</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">|  1 |      1 |             11 | astar的同事    |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">|  2 |      2 |             22 | jone的同事     |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">|  3 |      3 |             33 | tom的同事      |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">|  4 |      4 |             66 | jack的同事     |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">+----+--------+----------------+----------------+</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">4 rows in set (0.00 sec)</span></pre></td></tr></table></figure></li><li><p>2张表中belong字段代表归属于某个用户id，各自的*_count字段是汇总数量，拥有多少个朋友/同事。现在需要统计各个用户的同事+朋友的总数。</p></li><li><p>第一个反应的就是left/right join外连接的方式，用用户id做连接条件。但是某些用户只在其中一张表中有数据，比如mark在同事表中没有数据，jack在朋友表中没有数据。显然这种方式满足不了需求，需要2张表的全量数据，于是联想到了full join。</p></li><li><p>mysql数据库不支持full join(全连接)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">SELECT</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  a.belong,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  sum(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    IFNULL( a.friend_count, 0 ) + IFNULL( b.workmate_count, 0 ) </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  ) </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">FROM</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  friends a</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  FULL JOIN workmates b ON a.belong &#x3D; b.belong</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  GROUP BY a.belong</span></pre></td></tr></table></figure><p><img src="/2018/11/02/second/error.png" alt="alt"></p></li></ul><hr><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ul><li><p>2张表目前的情况如图：<br><img src="/2018/11/02/second/intersection.png" alt="alt"><br>需要的是一张表的全量(包含交集部分)+另一张表独有的数据<br><img src="/2018/11/02/second/complete.png" alt="alt"></p></li><li><p>一张表全量部分，用left/right join即可解决</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">SELECT</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">   a.belong,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">   sum(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">     IFNULL( b.friend_count, 0 ) + IFNULL( a.workmate_count, 0 ) </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">   ) count_all</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">FROM</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">   workmates a</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">   LEFT JOIN friends b ON a.belong &#x3D; b.belong</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">   GROUP BY a.belong;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">+--------+-----------+</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">| belong | count_all |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">+--------+-----------+</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">|      1 |       110 |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">|      2 |        99 |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">|      3 |        41 |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">|      4 |        66 |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">+--------+-----------+</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">4 rows in set (0.00 sec)</span></pre></td></tr></table></figure></li><li><p>求另一张表独有数据，需要排除交集部分，所以需要使用where条件做过滤:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">SELECT</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  a.belong,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  sum(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    IFNULL( a.friend_count, 0 ) + IFNULL( b.workmate_count, 0 ) </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  ) count_all </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">FROM</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  friends a</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  LEFT JOIN workmates b ON a.belong &#x3D; b.belong </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">where </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  b.id is null -- 排除与workmates有交集部分</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">GROUP BY</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">  a.belong;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">+--------+-----------+</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">| belong | count_all |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">+--------+-----------+</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">|      5 |       233 |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">+--------+-----------+</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">1 row in set (0.00 sec)</span></pre></td></tr></table></figure></li><li><p>最后结果数据合并，使用union即可:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">SELECT</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  a.belong,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  sum(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    IFNULL( b.friend_count, 0 ) + IFNULL( a.workmate_count, 0 ) </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  ) count_all </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">FROM</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  workmates a</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  LEFT JOIN  friends b ON a.belong &#x3D; b.belong </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">GROUP BY</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  a.belong</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">UNION </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">SELECT</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">  a.belong,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">  sum(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    IFNULL( a.friend_count, 0 ) + IFNULL( b.workmate_count, 0 ) </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">  ) count_all </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">FROM</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">  friends a</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">  LEFT JOIN workmates b ON a.belong &#x3D; b.belong </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">WHERE</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">  b.belong IS NULL </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">GROUP BY</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">  a.belong;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">+--------+-----------+</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">| belong | count_all |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">+--------+-----------+</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">|      1 |       110 |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">|      2 |        99 |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">|      3 |        41 |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">|      4 |        66 |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">|      5 |       233 |</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">+--------+-----------+</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">5 rows in set (0.00 sec)</span></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> full join </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇文章</title>
      <link href="/2018/10/05/first/"/>
      <url>/2018/10/05/first/</url>
      
        <content type="html"><![CDATA[<p>从最初php的WorldPress，到java的tale，再到现在基于pug的hexo，blog系统是越来越轻，也越来越傻瓜式。<br>技术的更新迭代仿佛带有加速度，日新月异，愈发体会到IT是个活到老学到老的行业。<br>长路漫漫，键盘作伴^_^<br><img src="/2018/10/05/first/littlecoder.png" alt="littleCoder"></p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> imagination </tag>
            
            <tag> inspiration </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
